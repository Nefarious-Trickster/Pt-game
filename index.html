<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Skyward Ruins: Reforged</title>
  <style>
    :root {
      --ui-bg: rgba(6, 10, 24, 0.76);
      --ui-border: rgba(162, 201, 255, 0.35);
      --text: #e8f3ff;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      display: grid;
      place-items: center;
      background:
        radial-gradient(circle at 15% 10%, #4359bd 0%, transparent 38%),
        radial-gradient(circle at 82% 18%, #7240ba 0%, transparent 33%),
        linear-gradient(180deg, #06091d 0%, #090d24 50%, #04060f 100%);
      font-family: Inter, Segoe UI, system-ui, sans-serif;
      color: var(--text);
      overflow: hidden;
    }
    #wrap {
      position: relative;
      width: min(96vw, 1400px);
      aspect-ratio: 16 / 9;
      border-radius: 20px;
      overflow: hidden;
      border: 1px solid rgba(163, 193, 255, 0.35);
      box-shadow: 0 30px 90px rgba(0, 0, 0, 0.6), inset 0 0 60px rgba(122, 151, 255, 0.1);
      background: #000;
    }
    canvas { width: 100%; height: 100%; display: block; }
    .hud {
      position: absolute;
      top: 12px;
      left: 12px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      z-index: 4;
    }
    .chip {
      background: var(--ui-bg);
      border: 1px solid var(--ui-border);
      border-radius: 10px;
      backdrop-filter: blur(5px);
      padding: 8px 11px;
      font-size: clamp(12px, 1.2vw, 15px);
      font-weight: 600;
    }
    .panel {
      position: absolute;
      inset: 0;
      z-index: 5;
      display: grid;
      place-items: center;
      background: rgba(2, 3, 8, 0.35);
    }
    .card {
      width: min(80%, 720px);
      border-radius: 15px;
      border: 1px solid rgba(178, 211, 255, 0.3);
      padding: clamp(18px, 2.6vw, 34px);
      background: linear-gradient(180deg, rgba(16, 29, 64, 0.92), rgba(10, 13, 32, 0.85));
      box-shadow: 0 20px 70px rgba(0, 0, 0, 0.6);
      text-align: center;
    }
    h1, h2 { margin: 0 0 10px; }
    p { color: #c8d8ff; line-height: 1.45; }
    button {
      border: 0;
      border-radius: 10px;
      padding: 11px 18px;
      font-weight: 800;
      color: #042140;
      cursor: pointer;
      background: linear-gradient(180deg, #67f4ff, #30b7ff);
    }
    kbd {
      border: 1px solid rgba(255, 255, 255, 0.23);
      background: rgba(255,255,255,.12);
      border-radius: 5px;
      padding: 1px 6px;
    }
    .hidden { display: none !important; }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="game" width="1600" height="900"></canvas>

  <div class="hud">
    <div class="chip" id="hudLevel"></div>
    <div class="chip" id="hudGems"></div>
    <div class="chip" id="hudLives"></div>
    <div class="chip" id="hudDash"></div>
    <div class="chip" id="hudTime"></div>
    <div class="chip" id="hudTip"></div>
  </div>

  <div class="panel" id="startPanel">
    <div class="card">
      <h1>Skyward Ruins: Reforged</h1>
      <p>Completely reworked mechanics and giant levels. Use grappling, sword slashes, and ground-smash routes to cross ruins that are built to take <strong>30-120 seconds each</strong>.</p>
      <p>
        Move <kbd>A/D</kbd> · Jump <kbd>Space</kbd> · Dash <kbd>Shift</kbd> · Slash <kbd>J</kbd> · Grapple <kbd>E</kbd> · Ground Smash <kbd>S</kbd> in air
      </p>
      <button id="startBtn">Start Adventure</button>
    </div>
  </div>

  <div class="panel hidden" id="messagePanel">
    <div class="card">
      <h2 id="msgTitle">Level Complete</h2>
      <p id="msgText"></p>
      <button id="msgBtn">Continue</button>
    </div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const ui = {
    level: document.getElementById('hudLevel'),
    gems: document.getElementById('hudGems'),
    lives: document.getElementById('hudLives'),
    dash: document.getElementById('hudDash'),
    time: document.getElementById('hudTime'),
    tip: document.getElementById('hudTip'),
    startPanel: document.getElementById('startPanel'),
    messagePanel: document.getElementById('messagePanel'),
    msgTitle: document.getElementById('msgTitle'),
    msgText: document.getElementById('msgText'),
    msgBtn: document.getElementById('msgBtn'),
    startBtn: document.getElementById('startBtn')
  };

  const keys = {};
  let gameState = 'menu';
  let levelIndex = 0;
  let active = null;
  let cameraX = 0;
  let shake = 0;
  let particles = [];
  let now = 0;

  const physics = {
    gravity: 0.6,
    friction: 0.84,
    airFriction: 0.95
  };

  const player = {
    x: 120, y: 700, w: 44, h: 64,
    vx: 0, vy: 0,
    facing: 1,
    grounded: false,
    jumpsLeft: 2,
    coyote: 0,
    jumpBuffer: 0,
    dashCD: 0,
    dashing: 0,
    dashReady: true,
    slam: false,
    slashTimer: 0,
    slashCD: 0,
    grapple: null,
    invuln: 0,
    lives: 4,
    spawnX: 120,
    spawnY: 700,
    levelStartTime: 0,
    levelElapsed: 0,
    tips: 'Reach the exit gate.'
  };

  const levels = [
    buildLevel('Titan Causeway', 4200, ['#254ab7', '#16285f', '#0a1027'], [100, 760], [4030, 210], 8,
      [
        [0, 840, 4200, 80], [180, 730, 180, 30], [520, 660, 170, 28], [900, 610, 180, 26],
        [1260, 560, 180, 26], [1620, 510, 200, 24], [1960, 460, 210, 24], [2300, 390, 190, 24],
        [2600, 330, 200, 24], [2920, 280, 190, 24], [3270, 260, 170, 24], [3570, 220, 180, 24],
        [3850, 260, 160, 24], [1200, 770, 140, 16, 'breakable'], [2140, 700, 130, 16, 'breakable'],
        [2800, 730, 120, 16, 'breakable'], [3340, 620, 130, 16, 'moving', {axis:'y', range:120, speed:1.8}],
        [2420, 550, 120, 16, 'moving', {axis:'x', range:160, speed:1.5}]
      ],
      [[700,810,430,1050,1.8,'walker'], [1750,790,1600,2300,2.1,'walker'], [3020,250,2930,3400,2.4,'walker'], [3460,180,3350,3880,2,'flyer']],
      [[550,615],[930,560],[1700,460],[2350,345],[2650,280],[3220,225],[3920,210],[4020,180]],
      [[1180,680],[2120,620],[2790,650]],
      [[1510,420],[2480,230],[3400,130]]
    ),
    buildLevel('Mirage Foundry', 5200, ['#512db7', '#2b1f66', '#100d2a'], [90, 760], [4980, 110], 9,
      [
        [0,840,5200,80], [150,730,200,26], [500,680,190,26], [860,610,180,24], [1240,560,180,24],
        [1570,510,170,24], [1870,450,170,24], [2180,390,170,24], [2520,340,190,24], [2860,300,190,24],
        [3220,260,190,24], [3560,220,190,24], [3900,200,180,24], [4240,170,180,24], [4580,140,170,24],
        [4820,170,120,20], [1060,770,130,16,'breakable'], [1410,730,120,16,'breakable'], [2110,320,130,16,'breakable'],
        [3300,730,120,16,'moving',{axis:'x',range:240,speed:2.1}], [3760,470,120,16,'moving',{axis:'y',range:160,speed:1.7}],
        [4370,520,120,16,'moving',{axis:'y',range:210,speed:1.9}], [4680,380,130,16,'moving',{axis:'x',range:170,speed:1.6}]
      ],
      [[610,650,540,1100,2,'walker'], [1940,420,1850,2360,2.3,'walker'], [3010,270,2960,3510,2.5,'walker'],
       [3920,170,3880,4440,2.6,'flyer'], [4480,110,4420,4980,2.8,'flyer']],
      [[530,635],[900,560],[1270,510],[1910,400],[2600,290],[3300,240],[3980,175],[4300,135],[4890,100]],
      [[1020,690],[2140,245],[4020,95]],
      [[1450,420],[2440,200],[3720,130],[4610,80]]
    ),
    buildLevel('Eclipse Engine', 6100, ['#93306d', '#4b1f51', '#160e29'], [90, 760], [5840, 100], 10,
      [
        [0,840,6100,80], [180,730,180,28], [520,680,180,26], [860,640,180,24], [1180,600,180,24],
        [1520,560,180,24], [1840,520,180,24], [2160,470,180,24], [2480,430,180,24], [2810,380,180,24],
        [3140,340,180,24], [3480,300,180,24], [3820,260,180,24], [4160,220,180,24], [4500,190,180,24],
        [4840,160,180,24], [5180,130,180,24], [5520,110,170,24], [5720,140,120,22],
        [1090,770,130,16,'breakable'], [1770,700,140,16,'breakable'], [2440,620,130,16,'breakable'], [3200,560,130,16,'breakable'],
        [3650,710,120,16,'moving',{axis:'x',range:290,speed:2.2}], [4300,520,120,16,'moving',{axis:'y',range:180,speed:2.0}],
        [4970,410,120,16,'moving',{axis:'x',range:230,speed:1.9}], [5480,300,120,16,'moving',{axis:'y',range:210,speed:2.1}]
      ],
      [[680,650,610,1300,2.2,'walker'], [2140,440,2050,2700,2.5,'walker'], [3220,310,3170,3860,2.7,'walker'],
       [4230,180,4200,4900,2.9,'flyer'], [5310,120,5260,5860,3.1,'flyer']],
      [[530,640],[890,590],[1220,550],[1910,470],[2520,380],[3190,290],[3870,230],[4550,170],[5230,110],[5790,90]],
      [[1080,700],[2450,545],[5250,95]],
      [[1520,430],[2770,220],[3980,150],[5480,130]]
    )
  ];

  function buildLevel(name, width, sky, spawn, exit, expectedSec, platforms, enemies, gems, checkpoints, grappleNodes) {
    return { name, width, sky, spawn, exit: { x: exit[0], y: exit[1], w: 68, h: 92 }, expectedSec,
      platforms: platforms.map(p => {
        const base = { x: p[0], y: p[1], w: p[2], h: p[3], type: p[4] || 'solid' };
        if (p[5]) Object.assign(base, p[5], { baseX: p[0], baseY: p[1], dir: 1 });
        return base;
      }),
      enemies: enemies.map(e => ({ x: e[0], y: e[1], w: 48, h: 34, minX: e[2], maxX: e[3], speed: e[4], type: e[5], dir: 1, alive: true })),
      gems: gems.map(g => ({ x: g[0], y: g[1], taken: false })),
      checkpoints: checkpoints.map(c => ({ x: c[0], y: c[1], reached: false })),
      grappleNodes: grappleNodes.map(n => ({ x: n[0], y: n[1] }))
    };
  }

  function cloneLevel(src) {
    return {
      ...src,
      platforms: src.platforms.map(p => ({ ...p })),
      enemies: src.enemies.map(e => ({ ...e })),
      gems: src.gems.map(g => ({ ...g })),
      checkpoints: src.checkpoints.map(c => ({ ...c })),
      grappleNodes: src.grappleNodes.map(n => ({ ...n }))
    };
  }

  function loadLevel(index) {
    active = cloneLevel(levels[index]);
    levelIndex = index;
    player.x = active.spawn[0];
    player.y = active.spawn[1];
    player.spawnX = player.x;
    player.spawnY = player.y;
    player.vx = player.vy = 0;
    player.jumpsLeft = 2;
    player.dashCD = 0;
    player.dashReady = true;
    player.grounded = false;
    player.slam = false;
    player.grapple = null;
    player.levelStartTime = performance.now();
    player.levelElapsed = 0;
    player.tips = 'Collect gems to open the gate.';
    particles = [];
    cameraX = 0;
    refreshHUD();
  }

  function showMessage(title, text, cb) {
    gameState = 'message';
    ui.msgTitle.textContent = title;
    ui.msgText.textContent = text;
    ui.messagePanel.classList.remove('hidden');
    ui.msgBtn.onclick = () => {
      ui.messagePanel.classList.add('hidden');
      cb();
    };
  }

  function refreshHUD() {
    if (!active) return;
    const got = active.gems.filter(g => g.taken).length;
    const secs = (player.levelElapsed / 1000).toFixed(1);
    ui.level.textContent = `Level ${levelIndex + 1}: ${active.name}`;
    ui.gems.textContent = `Gems ${got}/${active.gems.length}`;
    ui.lives.textContent = `Lives ${player.lives}`;
    ui.dash.textContent = player.dashReady ? 'Dash Ready' : `Dash ${(player.dashCD / 60).toFixed(1)}s`;
    ui.time.textContent = `Time ${secs}s · Target ${active.expectedSec}s+`;
    ui.tip.textContent = player.tips;
  }

  function overlap(a, b) {
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  function spawnBurst(x, y, color, amount = 14, spread = 6) {
    for (let i = 0; i < amount; i++) {
      particles.push({ x, y, vx: (Math.random() - 0.5) * spread, vy: (Math.random() - 0.6) * spread, life: 35 + Math.random() * 25, size: 2 + Math.random() * 4, color });
    }
  }

  function hurtPlayer() {
    if (player.invuln > 0) return;
    player.lives -= 1;
    player.invuln = 85;
    shake = 15;
    spawnBurst(player.x + player.w / 2, player.y + player.h / 2, '#ff7897', 26, 8);
    if (player.lives <= 0) {
      showMessage('Defeat', 'You were overwhelmed. Restarting from level 1.', () => {
        player.lives = 4;
        loadLevel(0);
        gameState = 'playing';
      });
    } else {
      player.x = player.spawnX;
      player.y = player.spawnY;
      player.vx = player.vy = 0;
      player.grapple = null;
      player.tips = 'Respawned at last checkpoint.';
    }
  }

  function completeLevel() {
    const totalSec = (player.levelElapsed / 1000).toFixed(1);
    if (levelIndex < levels.length - 1) {
      showMessage('Level Cleared', `You finished in ${totalSec}s. Next: ${levels[levelIndex + 1].name}`, () => {
        loadLevel(levelIndex + 1);
        gameState = 'playing';
      });
    } else {
      showMessage('Victory', `Final clear time: ${totalSec}s. You conquered all giant ruins.`, () => {
        player.lives = 4;
        loadLevel(0);
        gameState = 'playing';
      });
    }
  }

  function getInputAxis() {
    const left = keys['a'] || keys['arrowleft'];
    const right = keys['d'] || keys['arrowright'];
    return (right ? 1 : 0) - (left ? 1 : 0);
  }

  function nearestGrappleNode() {
    let best = null;
    let bestDist = 99999;
    for (const n of active.grappleNodes) {
      const dx = n.x - (player.x + player.w / 2);
      const dy = n.y - (player.y + player.h / 2);
      const d = Math.hypot(dx, dy);
      if (d < 330 && d < bestDist) {
        best = n;
        bestDist = d;
      }
    }
    return best;
  }

  function handleInput() {
    const axis = getInputAxis();
    if (!player.grapple) {
      player.vx += axis * 0.95;
      player.vx = Math.max(-8.8, Math.min(8.8, player.vx));
      if (axis !== 0) player.facing = axis;
    }

    if (keys[' '] || keys['w'] || keys['arrowup']) player.jumpBuffer = 8;

    if (player.jumpBuffer > 0) {
      if (player.grounded || player.coyote > 0) {
        player.vy = -14.2;
        player.grounded = false;
        player.coyote = 0;
        player.jumpsLeft = 1;
        player.jumpBuffer = 0;
        spawnBurst(player.x + player.w / 2, player.y + player.h, '#86ebff', 10);
      } else if (player.jumpsLeft > 0) {
        player.vy = -12.4;
        player.jumpsLeft = 0;
        player.jumpBuffer = 0;
        spawnBurst(player.x + player.w / 2, player.y + player.h / 2, '#68f4ff', 14);
      }
    }

    if ((keys['shift'] || keys['k']) && player.dashReady && player.dashing <= 0) {
      const axisDash = axis !== 0 ? axis : player.facing;
      player.dashing = 9;
      player.vx = axisDash * 15;
      player.vy *= 0.25;
      player.dashReady = false;
      player.dashCD = 120;
      spawnBurst(player.x + player.w / 2, player.y + player.h / 2, '#84f6ff', 22, 8);
      player.tips = 'Dash used. It recharges quickly.';
    }

    if (keys['j'] && player.slashCD <= 0) {
      player.slashTimer = 10;
      player.slashCD = 22;
      spawnBurst(player.x + player.facing * 14 + player.w / 2, player.y + 26, '#ffc990', 8, 5);
    }

    if ((keys['s'] || keys['arrowdown']) && !player.grounded && !player.slam) {
      player.slam = true;
      player.vy = 17;
      player.tips = 'Ground Smash can break cracked blocks.';
    }

    if (keys['e']) {
      if (!player.grapple) {
        const node = nearestGrappleNode();
        if (node) {
          player.grapple = { x: node.x, y: node.y };
          player.tips = 'Grapple latched. Swing and launch!';
        }
      }
    } else {
      if (player.grapple) {
        const dx = player.grapple.x - (player.x + player.w / 2);
        player.vx += Math.sign(dx) * 1.8;
      }
      player.grapple = null;
    }
  }

  function updatePhysics() {
    active.platforms.forEach(p => {
      if (p.type !== 'moving') return;
      if (p.axis === 'x') {
        p.x += p.speed * p.dir;
        if (Math.abs(p.x - p.baseX) > p.range) p.dir *= -1;
      } else {
        p.y += p.speed * p.dir;
        if (Math.abs(p.y - p.baseY) > p.range) p.dir *= -1;
      }
    });

    active.enemies.forEach(e => {
      if (!e.alive) return;
      if (e.type === 'walker') {
        e.x += e.speed * e.dir;
        if (e.x < e.minX || e.x + e.w > e.maxX) e.dir *= -1;
      } else {
        e.x += e.speed * e.dir;
        e.y += Math.sin((now + e.x) * 0.02) * 0.8;
        if (e.x < e.minX || e.x + e.w > e.maxX) e.dir *= -1;
      }
    });

    if (player.dashCD > 0) {
      player.dashCD -= 1;
      if (player.dashCD <= 0) player.dashReady = true;
    }
    if (player.dashing > 0) player.dashing -= 1;

    if (player.slashTimer > 0) player.slashTimer -= 1;
    if (player.slashCD > 0) player.slashCD -= 1;

    if (player.grapple) {
      const cx = player.x + player.w / 2;
      const cy = player.y + player.h / 2;
      const dx = player.grapple.x - cx;
      const dy = player.grapple.y - cy;
      player.vx += dx * 0.015;
      player.vy += dy * 0.015;
      player.vx *= 0.992;
      player.vy *= 0.992;
    } else if (player.dashing <= 0) {
      player.vy += physics.gravity;
    }

    player.vx *= player.grounded ? physics.friction : physics.airFriction;
    player.vx = Math.max(-14, Math.min(14, player.vx));
    player.vy = Math.max(-24, Math.min(22, player.vy));

    player.x += player.vx;
    for (const p of active.platforms) {
      if (p.type === 'breakable' && p.broken) continue;
      if (!overlap(player, p)) continue;
      if (player.vx > 0) { player.x = p.x - player.w; player.vx = 0; }
      else if (player.vx < 0) { player.x = p.x + p.w; player.vx = 0; }
    }

    player.y += player.vy;
    player.grounded = false;
    for (const p of active.platforms) {
      if (p.type === 'breakable' && p.broken) continue;
      if (!overlap(player, p)) continue;
      if (player.vy > 0) {
        player.y = p.y - player.h;
        player.vy = 0;
        player.grounded = true;
        player.jumpsLeft = 1;
        if (p.type === 'moving') {
          if (p.axis === 'x') player.x += p.speed * p.dir;
          else player.y += p.speed * p.dir;
        }
        if (player.slam) {
          shake = 10;
          spawnBurst(player.x + player.w / 2, player.y + player.h, '#fff39a', 20, 8);
          for (const b of active.platforms) {
            if (b.type === 'breakable' && !b.broken && Math.abs((b.x + b.w / 2) - (player.x + player.w / 2)) < 110 && Math.abs(b.y - (player.y + player.h)) < 80) {
              b.broken = true;
              spawnBurst(b.x + b.w / 2, b.y + b.h / 2, '#ffb890', 22, 10);
            }
          }
          player.slam = false;
        }
      } else if (player.vy < 0) {
        player.y = p.y + p.h;
        player.vy = 0;
      }
    }

    player.coyote = player.grounded ? 8 : Math.max(0, player.coyote - 1);
    player.jumpBuffer = Math.max(0, player.jumpBuffer - 1);

    player.x = Math.max(0, Math.min(active.width - player.w, player.x));
    if (player.y > canvas.height + 250) hurtPlayer();

    const slashHitbox = { x: player.x + (player.facing > 0 ? player.w - 6 : -42), y: player.y + 10, w: 42, h: 40 };
    for (const e of active.enemies) {
      if (!e.alive) continue;
      if (player.slashTimer > 0 && overlap(slashHitbox, e)) {
        e.alive = false;
        spawnBurst(e.x + e.w / 2, e.y + e.h / 2, '#ffc178', 20, 10);
        player.vx -= player.facing * 1.1;
        continue;
      }
      if (overlap(player, e)) {
        const stomp = player.vy > 1 && player.y + player.h - 12 < e.y;
        if (stomp) {
          e.alive = false;
          player.vy = -10;
          spawnBurst(e.x + e.w / 2, e.y + e.h / 2, '#ffad73', 18, 9);
        } else {
          hurtPlayer();
        }
      }
    }

    for (const g of active.gems) {
      if (g.taken) continue;
      if (overlap(player, { x: g.x - 12, y: g.y - 12, w: 24, h: 24 })) {
        g.taken = true;
        spawnBurst(g.x, g.y, '#63f6ff', 16, 7);
      }
    }

    for (const c of active.checkpoints) {
      if (!c.reached && overlap(player, { x: c.x - 22, y: c.y - 70, w: 44, h: 90 })) {
        c.reached = true;
        player.spawnX = c.x - 20;
        player.spawnY = c.y - 62;
        player.tips = 'Checkpoint reached.';
        spawnBurst(c.x, c.y - 45, '#9bff9e', 18, 5);
      }
    }

    const gotAll = active.gems.every(g => g.taken);
    if (gotAll && overlap(player, active.exit)) completeLevel();

    player.levelElapsed = performance.now() - player.levelStartTime;
    if (player.invuln > 0) player.invuln -= 1;
    cameraX = Math.max(0, Math.min(active.width - canvas.width, player.x - canvas.width * 0.36));
    refreshHUD();
  }

  function rr(x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }

  function drawBackground() {
    const [a, b, c] = active.sky;
    const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
    grad.addColorStop(0, a); grad.addColorStop(0.55, b); grad.addColorStop(1, c);
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    for (let layer = 0; layer < 3; layer++) {
      const speed = (0.12 + layer * 0.2);
      const baseH = 160 + layer * 70;
      const alpha = 0.09 + layer * 0.05;
      const shift = (cameraX * speed) % 450;
      ctx.fillStyle = `rgba(220,235,255,${alpha})`;
      for (let i = -1; i < 8; i++) {
        const x = i * 420 - shift;
        ctx.beginPath();
        ctx.moveTo(x, canvas.height);
        ctx.lineTo(x + 190, canvas.height - baseH - Math.sin((i + now * 0.02) * 1.7) * 20);
        ctx.lineTo(x + 380, canvas.height);
        ctx.closePath();
        ctx.fill();
      }
    }

    for (let i = 0; i < 130; i++) {
      const x = (i * 121 + now * 0.3) % canvas.width;
      const y = (i * 83 + Math.sin(i + now * 0.01) * 40) % canvas.height;
      ctx.fillStyle = `rgba(255,255,255,${0.12 + (i % 5) * 0.08})`;
      ctx.fillRect(x, y, 1.4 + (i % 2), 1.4 + (i % 2));
    }
  }

  function drawWorld() {
    drawBackground();
    ctx.save();
    ctx.translate(-cameraX, 0);

    // grapple nodes
    active.grappleNodes.forEach(n => {
      ctx.fillStyle = '#b5e9ff';
      ctx.beginPath(); ctx.arc(n.x, n.y, 7, 0, Math.PI * 2); ctx.fill();
      ctx.strokeStyle = '#e3f8ff';
      ctx.stroke();
    });

    // checkpoints
    active.checkpoints.forEach(c => {
      ctx.fillStyle = c.reached ? '#52ff9b' : '#9aa6d3';
      ctx.fillRect(c.x - 3, c.y - 72, 6, 72);
      ctx.beginPath();
      ctx.moveTo(c.x + 3, c.y - 72);
      ctx.lineTo(c.x + 46, c.y - 58);
      ctx.lineTo(c.x + 3, c.y - 44);
      ctx.closePath();
      ctx.fill();
    });

    active.platforms.forEach(p => {
      if (p.type === 'breakable' && p.broken) return;
      let c1 = '#708cff', c2 = '#31439a';
      if (p.type === 'moving') { c1 = '#88f4ff'; c2 = '#2b73b9'; }
      if (p.type === 'breakable') { c1 = '#ffbf87'; c2 = '#7f4e33'; }
      const g = ctx.createLinearGradient(p.x, p.y, p.x, p.y + p.h);
      g.addColorStop(0, c1); g.addColorStop(1, c2);
      ctx.fillStyle = g;
      rr(p.x, p.y, p.w, p.h, 8);
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,.22)';
      ctx.stroke();
      if (p.type === 'breakable') {
        ctx.strokeStyle = 'rgba(70,20,0,0.35)';
        ctx.beginPath();
        ctx.moveTo(p.x + 15, p.y + 4); ctx.lineTo(p.x + p.w - 12, p.y + p.h - 4);
        ctx.moveTo(p.x + p.w * 0.45, p.y + 3); ctx.lineTo(p.x + p.w * 0.22, p.y + p.h - 3);
        ctx.stroke();
      }
    });

    const allGems = active.gems.every(g => g.taken);
    active.gems.forEach(g => {
      if (g.taken) return;
      const pulse = 4 + Math.sin(now * 0.01 + g.x * 0.03) * 2.2;
      ctx.fillStyle = '#6af4ff';
      ctx.beginPath();
      ctx.moveTo(g.x, g.y - 12 - pulse * 0.2);
      ctx.lineTo(g.x + 11, g.y);
      ctx.lineTo(g.x, g.y + 12 + pulse * 0.2);
      ctx.lineTo(g.x - 11, g.y);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = '#ddffff';
      ctx.stroke();
    });

    const ex = active.exit;
    const gateG = ctx.createLinearGradient(ex.x, ex.y, ex.x, ex.y + ex.h);
    gateG.addColorStop(0, allGems ? '#79ffc5' : '#ff7c9e');
    gateG.addColorStop(1, allGems ? '#2ba786' : '#68254d');
    ctx.fillStyle = gateG;
    rr(ex.x, ex.y, ex.w, ex.h, 10);
    ctx.fill();
    ctx.strokeStyle = allGems ? '#e5fff2' : '#ffd6df';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.lineWidth = 1;

    active.enemies.forEach(e => {
      if (!e.alive) return;
      const eb = ctx.createLinearGradient(e.x, e.y, e.x, e.y + e.h);
      eb.addColorStop(0, e.type === 'flyer' ? '#ff9ce1' : '#ffa771');
      eb.addColorStop(1, e.type === 'flyer' ? '#8a357a' : '#8f3d2e');
      ctx.fillStyle = eb;
      rr(e.x, e.y, e.w, e.h, 10);
      ctx.fill();
      ctx.fillStyle = '#2f1238';
      ctx.fillRect(e.x + 10, e.y + 9, 8, 8);
      ctx.fillRect(e.x + e.w - 18, e.y + 9, 8, 8);
      if (e.type === 'flyer') {
        ctx.strokeStyle = 'rgba(255,255,255,.4)';
        ctx.beginPath();
        ctx.moveTo(e.x - 8, e.y + 18);
        ctx.quadraticCurveTo(e.x + 4, e.y - 2, e.x + 16, e.y + 16);
        ctx.moveTo(e.x + e.w - 8, e.y + 16);
        ctx.quadraticCurveTo(e.x + e.w + 4, e.y - 4, e.x + e.w + 16, e.y + 14);
        ctx.stroke();
      }
    });

    particles.forEach(p => {
      p.x += p.vx; p.y += p.vy; p.vy += 0.08; p.life -= 1;
      ctx.globalAlpha = Math.max(0, p.life / 42);
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x, p.y, p.size, p.size);
    });
    ctx.globalAlpha = 1;
    particles = particles.filter(p => p.life > 0);

    // player: more detailed
    if (!(player.invuln > 0 && Math.floor(player.invuln / 6) % 2 === 0)) {
      const px = player.x, py = player.y;
      const body = ctx.createLinearGradient(px, py, px, py + player.h);
      body.addColorStop(0, '#8af7ff'); body.addColorStop(1, '#258fff');
      ctx.fillStyle = body;
      rr(px, py + 8, player.w, player.h - 8, 11);
      ctx.fill();

      ctx.fillStyle = '#eaf8ff';
      rr(px + 8, py, player.w - 16, 16, 6);
      ctx.fill();
      ctx.fillStyle = '#123060';
      ctx.fillRect(px + 12, py + 4, 7, 6);
      ctx.fillRect(px + player.w - 19, py + 4, 7, 6);

      ctx.fillStyle = '#62c7ff';
      ctx.fillRect(px + 6, py + 26, player.w - 12, 6);

      ctx.fillStyle = '#5b2b9f';
      const capeX = player.facing > 0 ? px - 8 : px + player.w;
      ctx.beginPath();
      ctx.moveTo(capeX, py + 16);
      ctx.lineTo(capeX - player.facing * 18, py + 35 + Math.sin(now * 0.05) * 5);
      ctx.lineTo(capeX, py + 54);
      ctx.closePath();
      ctx.fill();

      if (player.slashTimer > 0) {
        ctx.strokeStyle = '#fff2af';
        ctx.lineWidth = 5;
        ctx.beginPath();
        const sx = player.facing > 0 ? px + player.w + 20 : px - 20;
        ctx.arc(sx, py + 30, 20, player.facing > 0 ? -1.4 : 2.5, player.facing > 0 ? 1.2 : 4.9);
        ctx.stroke();
        ctx.lineWidth = 1;
      }

      if (player.grapple) {
        ctx.strokeStyle = '#d4f7ff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(px + player.w / 2, py + 18);
        ctx.lineTo(player.grapple.x, player.grapple.y);
        ctx.stroke();
        ctx.lineWidth = 1;
      }
    }

    ctx.restore();
  }

  function tick() {
    requestAnimationFrame(tick);
    now += 1;
    if (!active) return;

    if (gameState === 'playing') {
      handleInput();
      updatePhysics();
    }

    shake *= 0.84;
    const sx = (Math.random() - 0.5) * shake;
    const sy = (Math.random() - 0.5) * shake;
    ctx.save();
    ctx.translate(sx, sy);
    drawWorld();
    ctx.restore();
  }

  function normKey(k) { return k.length === 1 ? k.toLowerCase() : k.toLowerCase(); }
  window.addEventListener('keydown', e => {
    const k = normKey(e.key);
    keys[k] = true;
    if ([ 'arrowup', 'arrowdown', 'arrowleft', 'arrowright', ' '].includes(k)) e.preventDefault();
  }, { passive: false });
  window.addEventListener('keyup', e => { keys[normKey(e.key)] = false; });

  ui.startBtn.addEventListener('click', () => {
    ui.startPanel.classList.add('hidden');
    loadLevel(0);
    gameState = 'playing';
  });

  loadLevel(0);
  tick();
})();
</script>
</body>
</html>
